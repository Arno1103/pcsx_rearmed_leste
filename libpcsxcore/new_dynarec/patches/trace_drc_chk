diff --git a/libpcsxcore/new_dynarec/linkage_arm.S b/libpcsxcore/new_dynarec/linkage_arm.S
index 1d8cefa..528929f 100644
--- a/libpcsxcore/new_dynarec/linkage_arm.S
+++ b/libpcsxcore/new_dynarec/linkage_arm.S
@@ -438,7 +438,7 @@ FUNCTION(cc_interrupt):
 	str	r1, [fp, #LO_pending_exception]
 	and	r2, r2, r10, lsr #17
 	add	r3, fp, #LO_restore_candidate
-	str	r10, [fp, #LO_cycle]		/* PCSX cycles */
+@@@	str	r10, [fp, #LO_cycle]		/* PCSX cycles */
 @@	str	r10, [fp, #LO_reg_cop0+36]	/* Count */
 	ldr	r4, [r2, r3]
 	mov	r10, lr
@@ -528,7 +528,7 @@ FUNCTION(new_dyna_leave):
 	ldr	r0, [fp, #LO_last_count]
 	add	r12, fp, #28
 	add	r10, r0, r10
-	str	r10, [fp, #LO_cycle]
+@@@	str	r10, [fp, #LO_cycle]
 	ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
 	.size	new_dyna_leave, .-new_dyna_leave
 
@@ -645,7 +645,7 @@ FUNCTION(new_dyna_start):
 	\readop	r0, [r1, r3, lsl #\tab_shift]
 .endif
 	movcc	pc, lr
-	str	r2, [fp, #LO_cycle]
+@@@	str	r2, [fp, #LO_cycle]
 	bx	r1
 .endm
 
@@ -680,7 +680,7 @@ FUNCTION(jump_handler_read32):
 	mov     r0, r1
 	add	r2, r2, r12
 	push	{r2, lr}
-	str	r2, [fp, #LO_cycle]
+@@@	str	r2, [fp, #LO_cycle]
 	blx	r3
 
 	ldr	r0, [fp, #LO_next_interupt]
@@ -708,7 +708,7 @@ FUNCTION(jump_handler_write_h):
 	add	r2, r2, r12
 	mov     r0, r1
 	push	{r2, lr}
-	str	r2, [fp, #LO_cycle]
+@@@	str	r2, [fp, #LO_cycle]
 	blx	r3
 
 	ldr	r0, [fp, #LO_next_interupt]
diff --git a/libpcsxcore/new_dynarec/linkage_arm64.S b/libpcsxcore/new_dynarec/linkage_arm64.S
index 7df82b4..79298e4 100644
--- a/libpcsxcore/new_dynarec/linkage_arm64.S
+++ b/libpcsxcore/new_dynarec/linkage_arm64.S
@@ -123,7 +123,7 @@ FUNCTION(cc_interrupt):
 	str	wzr, [rFP, #LO_pending_exception]
 	and	w2, w2, rCC, lsr #17
 	add	x3, rFP, #LO_restore_candidate
-	str	rCC, [rFP, #LO_cycle]		/* PCSX cycles */
+##	str	rCC, [rFP, #LO_cycle]		/* PCSX cycles */
 #	str	rCC, [rFP, #LO_reg_cop0+36]	/* Count */
 	ldr	w19, [x3, w2, uxtw]
 	mov	x21, lr
@@ -231,7 +231,7 @@ FUNCTION(new_dyna_start):
 FUNCTION(new_dyna_leave):
 	ldr	w0,  [rFP, #LO_last_count]
 	add	rCC, rCC, w0
-	str	rCC, [rFP, #LO_cycle]
+##	str	rCC, [rFP, #LO_cycle]
 	ldp	x19, x20, [sp, #16*1]
 	ldp	x21, x22, [sp, #16*2]
 	ldp	x23, x24, [sp, #16*3]
@@ -249,7 +249,7 @@ FUNCTION(new_dyna_leave):
 	/* w0 = adddr/data, x1 = rhandler, w2 = cycles, x3 = whandler */
 	ldr	w4, [rFP, #LO_last_count]
 	add	w4, w4, w2
-	str	w4, [rFP, #LO_cycle]
+##	str	w4, [rFP, #LO_cycle]
 .endm
 
 .macro memhandler_post
diff --git a/libpcsxcore/new_dynarec/new_dynarec.c b/libpcsxcore/new_dynarec/new_dynarec.c
index 2f77516..21481bc 100644
--- a/libpcsxcore/new_dynarec/new_dynarec.c
+++ b/libpcsxcore/new_dynarec/new_dynarec.c
@@ -521,6 +521,9 @@ static int doesnt_expire_soon(void *tcaddr)
 // This is called from the recompiled JR/JALR instructions
 void noinline *get_addr(u_int vaddr)
 {
+#ifdef DRC_DBG
+printf("get_addr %08x, pc=%08x\n", vaddr, psxRegs.pc);
+#endif
   u_int page=get_page(vaddr);
   u_int vpage=get_vpage(vaddr);
   struct ll_entry *head;
@@ -4790,13 +4793,15 @@ void do_cc(int i,signed char i_regmap[],int *adj,int addr,int taken,int invert)
 #endif
     emit_addimm_and_set_flags(cycles,HOST_CCREG);
     jaddr=out;
-    emit_jns(0);
+    //emit_jns(0);
+   emit_jmp(0);
   }
   else
   {
     emit_cmpimm(HOST_CCREG,-CLOCK_ADJUST(count+2));
     jaddr=out;
-    emit_jns(0);
+    //emit_jns(0);
+   emit_jmp(0);
   }
   add_stub(CC_STUB,jaddr,idle?idle:out,(*adj==0||invert||idle)?0:(count+2),i,addr,taken,0);
 }
@@ -5204,7 +5209,8 @@ static void rjump_assemble(int i,struct regstat *i_regs)
     // special case for RFE
     emit_jmp(0);
   else
-    emit_jns(0);
+    //emit_jns(0);
+   emit_jmp(0);
   //load_regs_bt(branch_regs[i].regmap,branch_regs[i].dirty,-1);
   #ifdef USE_MINI_HT
   if(dops[i].rs1==31) {
@@ -5309,7 +5315,8 @@ static void cjump_assemble(int i,struct regstat *i_regs)
     else if(nop) {
       emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),cc);
       void *jaddr=out;
-      emit_jns(0);
+      //emit_jns(0);
+     emit_jmp(0);
       add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
     }
     else {
@@ -5496,7 +5503,8 @@ static void cjump_assemble(int i,struct regstat *i_regs)
         emit_loadreg(CCREG,HOST_CCREG);
         emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),HOST_CCREG);
         void *jaddr=out;
-        emit_jns(0);
+        //emit_jns(0);
+       emit_jmp(0);
         add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
         emit_storereg(CCREG,HOST_CCREG);
       }
@@ -5505,7 +5513,8 @@ static void cjump_assemble(int i,struct regstat *i_regs)
         assert(cc==HOST_CCREG);
         emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),cc);
         void *jaddr=out;
-        emit_jns(0);
+        //emit_jns(0);
+       emit_jmp(0);
         add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
       }
     }
@@ -5607,7 +5616,8 @@ static void sjump_assemble(int i,struct regstat *i_regs)
     else if(nevertaken) {
       emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),cc);
       void *jaddr=out;
-      emit_jns(0);
+      //emit_jns(0);
+     emit_jmp(0);
       add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
     }
     else {
@@ -5763,7 +5773,8 @@ static void sjump_assemble(int i,struct regstat *i_regs)
         emit_loadreg(CCREG,HOST_CCREG);
         emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),HOST_CCREG);
         void *jaddr=out;
-        emit_jns(0);
+        //emit_jns(0);
+       emit_jmp(0);
         add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
         emit_storereg(CCREG,HOST_CCREG);
       }
@@ -5772,7 +5783,8 @@ static void sjump_assemble(int i,struct regstat *i_regs)
         assert(cc==HOST_CCREG);
         emit_addimm_and_set_flags(CLOCK_ADJUST(ccadj[i]+2),cc);
         void *jaddr=out;
-        emit_jns(0);
+        //emit_jns(0);
+       emit_jmp(0);
         add_stub(CC_STUB,jaddr,out,0,i,start+i*4+8,NOTTAKEN,0);
       }
     }
@@ -6211,7 +6223,7 @@ void unneeded_registers(int istart,int iend,int r)
     // R0 is always unneeded
     u|=1;
     // Save it
-    unneeded_reg[i]=u;
+    unneeded_reg[i]=1;//u;
     gte_unneeded[i]=gte_u;
     /*
     printf("ur (%d,%d) %x: ",istart,iend,start+i*4);
@@ -8756,6 +8768,7 @@ int new_recompile_block(u_int addr)
 
   // This allocates registers (if possible) one instruction prior
   // to use, which can avoid a load-use penalty on certain CPUs.
+#if 0
   for(i=0;i<slen-1;i++)
   {
     if (!i || !dops[i-1].is_jump)
@@ -8912,6 +8925,7 @@ int new_recompile_block(u_int addr)
       }
     }
   }
+#endif
 
   /* Pass 6 - Optimize clean/dirty state */
   clean_registers(0,slen-1,1);
@@ -9217,6 +9231,11 @@ int new_recompile_block(u_int addr)
         case SPAN:
           pagespan_assemble(i,&regs[i]);break;
       }
+#ifdef DRC_DBG
+       // write-out non-consts, consts are likely different because of get_final_value()
+       if (!dops[i].is_jump)
+         wb_dirtys(regs[i].regmap,regs[i].dirty&~regs[i].loadedconst);
+#endif
       if (dops[i].is_ujump)
         literal_pool(1024);
       else
@@ -9451,6 +9470,10 @@ int new_recompile_block(u_int addr)
   }
 #ifdef ASSEM_PRINT
   fflush(stdout);
+#endif
+#ifdef DRC_DBG
+printf("new_recompile_block done\n");
+fflush(stdout);
 #endif
   return 0;
 }
